// webppl rsa.wppl --require .
var nnparam = function(a, b) {
  return tensorParam([a, b], 0, 0.1);
};


var worldPrior = function() {
    // Return a distribution over worlds

};
var literalListener = cache(function(utterance,params) {
  Infer({method: 'enumerate'},function(){
        var world = worldPrior()
        factor(truth(utterance, world, params, "$S"))
        return world
    })
})

var speaker = cache(function(world,params) {
  Infer({method: 'enumerate'},function(){
        var utterance = utterancePrior()
        var L = literalListener(utterance,W,b)

        factor(L.score(world))

        return utterance
    })
})

var listener = cache(function(utterance,params) {
  Infer({method: 'enumerate'},function(){
        var world = worldPrior()
        var S = speaker(world,W,b)
        factor(S.score(utterance))
        return world
    })
})

var truth = function(utterance, world, params, startSymbol) {
    var chart = parser.call(utterance, params);
    var rootCellDerivations = semppl.getRootCellDerivations(chart, startSymbol);

    // Gather the two relevant probabilities
    var derivationProbabilities = map(function(d) {
        return Math.exp(scoreFn(featureFn(d), params));
    }, rootCellDerivations);

    // World dependent part starts here.
    var truthProbabilities = map(denotationProbability(world), rootCellDerivations);
    
    // We now have probabilities that the sentences are true given derivations P(t | d)
    // Also probabilities that derivations are correct P(d)

    // Marginalize out derivation by summing over derivations, multiply the two probabilities
    return sum(map2(function(derivation, truth) {
        return derivation * truth;
    }, derivationProbabilities, truthProbabilities));
};

var sampleMatrixGaussian = function(dims,mean,variance,guide_mean){
  var length = dims[0]*dims[1]
  var g = sample(DiagCovGaussian({ mu: Vector(repeat(length, constF(mean))), sigma: Vector(repeat(length, constF(variance)))}),
    {guide: DiagCovGaussian({ mu: T.reshape(guide_mean,[length,1]), sigma: Vector(repeat(length, constF(0.001)))})})
  return T.reshape(g,dims)
}

var denotationProbability = function(world) {
    return function(derivation) {
        return derivation.semantics(world);
    };
};

var featureFn = function(d) { return semppl.ruleFeatureFn(d); };
var scoreFn = function(features, params) {
    return sum(_.values(mapObject(function(k, v) {
        return _.has(params, k) ? v * params[k] : 0;
    }, features)));
};

var parser = { call: semppl.createParser(semppl.grammarIsTall) };
var model = function() {
    var h_size = 10
    var ent_size = 3

    var W0_var = nnparam(h_size,ent_size)
    var W1_var = nnparam(1,h_size)
    var b0_var = nnparam(h_size,1)
    var b1_var = nnparam(1,1)

    var W0 = sampleMatrixGaussian([h_size,ent_size],0,10,W0_var)
    var W1 = sampleMatrixGaussian([1,h_size],0,10,W1_var)
    var b0 = sampleMatrixGaussian([h_size,1],0,10,b0_var)
    var b1 = sampleMatrixGaussian([1,1],0,10,b1_var)

    // Question: How to make an input vector that reflects john's height
    var world1 = {
        model: { height: { john: 6.5 } },
        theta: { tall: 0.6 },
        params: { tall: { W: [W0, W1], b: [b0, b1] } },
        domain: ["john"]
    };
    var params = { 
        '$NP -> John': 1,
        '$COP -> is': 1,
        '$ADJ -> tall': 1,
        '$VP -> $COP $ADJ': 1,
        '$S -> $NP $VP': 1
    };
    factor(Math.log(truth("John is tall", world1, params, "$S")))
};
var p = Optimize(model, {steps: 2000, estimator: {ELBO: {samples: 1}}});