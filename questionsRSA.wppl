var questionStartSymbol = "$WH";
var answerStartSymbol = "$S";

var KL = function(p, q){
    return expectation(p, function(value) {
        var scoreP = p.score(value);
        var scoreQ = q.score(value);
        return scoreP === -Infinity ? 0 : scoreP - scoreQ;
    });
};

var utteranceDist = function(utterances, costFn, rationality) {
    var probabilities = map(function(u) {
        return Math.exp(-rationality * costFn(u));
    }, utterances);
    return Categorical({ ps: probabilities, vs: utterances });
}

var createVariationalModel = function(questions, answers, costFn, worldPrior, qudCandidates, 
                                      rationality, grammarFn, parametrizedNetworks, observationFn, 
                                      opts, experimentName, runId) {
    var runPath = makeRunPath(experimentName, runId);
    var modelFn = function() {
        var specifiedNetworks = mapObject(function(k, v) {
            var params = apply(v.paramConstructor, [k]);
            return v.runner(params);
        }, parametrizedNetworks)
        var grammar = grammarFn.call(null, specifiedNetworks);
        var parser = createParser(grammar, createParserWeights(grammar));
        var model = createModel(questions, answers, costFn, worldPrior, qudCandidates, rationality, parser);
        if (observationFn) {
            observationFn(model);
        }
        return _.assign({ networks: specifiedNetworks }, model);
    }

    if (fs.existsSync(runPath.paramsPath)) {
        // Restore previously learned params
        var params = webpplFs.read(runPath.paramsPath);
        setParams(deserializeParams(params));
    }
    else {
        // learn new params
        var optsWithFilenames = _.assign({ 
            model: modelFn,
            checkpointParamsFilename: runPath.paramsPath,
            logProgressFilename: runPath.logPath
        }, opts);
        Optimize(optsWithFilenames);
    }
                                     
    return sample(SampleGuide(modelFn));
}

var createModel = function(questions, answers, costFn, worldPrior, qudCandidates, rationality, parser) {
    var questionsDist = utteranceDist(questions, costFn, rationality);
    var answersDist = utteranceDist(answers, costFn, rationality);

    var interpretAnswer = mem(function(answer) {
        var answerMeaning = parser(answer, answerStartSymbol);
        return Infer({method: 'enumerate'}, function() {
            var world = sample(worldPrior);
            factor(Math.log(answerMeaning(world)));
            return world;
        });
    })

    var informationGainFn = function(answerer) {
        return mem(function(question, qudIndex, trueWorld) {
            var qudFn = qudCandidates[qudIndex];
            var prior = marginalize(worldPrior, qudFn);
            var answerDist = answerer(question, trueWorld);
            var posterior = Infer({method: 'enumerate'}, function() {
                var answer = sample(answersDist);
                var world = sample(interpretAnswer(answer));
                return qudFn(world);
            });

            return KL(posterior, prior);
        })
    }
    
    var similarity = mem(function(question, trueWorld, otherWorld, domain) {
        // trueWorldPredicate and otherWorldPredicate are each distributions
        // over subsets of the domain. Compute KL between them using factorization
        // for sequence of independent bernoulli trials.
        var questionMeaning = parser(question, questionStartSymbol);
        var trueWorldPredicate = questionMeaning(trueWorld);
        var otherWorldPredicate = questionMeaning(otherWorld);
        return Math.exp(-sum(map(function(e) {
            var p_e = trueWorldPredicate(e);
            var q_e = otherWorldPredicate(e);
            var positiveTerm = p_e === 0 ? 0 : p_e * Math.log(p_e / q_e);
            var negativeTerm = p_e === 1 ? 0 : (1 - p_e) * Math.log((1 - p_e) / (1 - q_e));
            return positiveTerm + negativeTerm;
        }, domain)));
    })

    var answerQualityForQuestion = mem(function(answer, question, trueWorld) {
        // Using soft similarity semantics
        var consistentWorlds = interpretAnswer(answer);
        return Math.log(expectation(consistentWorlds, function(w) {
            assert.ok(w.domain.length === trueWorld.domain.length)
            return similarity(question, trueWorld, w, trueWorld.domain);
        }))
    })

    var answerQualityForQud = mem(function(answer, qudIndex, trueWorld) {
        // Using hard partition semantics
        var consistentWorlds = interpretAnswer(answer);
        var qud = qudCandidates[qudIndex];
        return marginalize(consistentWorlds, qud).score(qud(trueWorld));
    })

    var explicitAnswerer = mem(function(question, trueWorld) {
        return Infer({method: 'enumerate'}, function() {
            var answer = sample(answersDist);
            var answerMeaning = parser(answer, answerStartSymbol);
            factor(Math.log(answerMeaning(trueWorld)) * rationality);
            factor(answerQualityForQuestion(answer, question, trueWorld)
                * rationality);
            return answer;
        })
    })

    var questioner = function(answerer) {
        var informationGain = informationGainFn(answerer);
        return mem(function(qudIndex) {
            return Infer({method: 'enumerate'}, function() {
                var question = sample(questionsDist)
                var expectedInformationGain = expectation(worldPrior, function(world) {
                    return informationGain(question, qudIndex, world);
                });
                factor(expectedInformationGain * rationality);
                return question;
            });
        })
    }

    var explicitQuestioner = questioner(explicitAnswerer);

    var pragmaticAnswerer = mem(function(question, trueWorld) {
        return Infer({method: 'enumerate'}, function() {
            var qudIndex = uniformDraw(_.keys(qudCandidates));
            var questionDist = explicitQuestioner(qudIndex);
            var answer = sample(answersDist)
            factor((questionDist.score(question)
                    + answerQualityForQud(answer, qudIndex, trueWorld))
                    * rationality);
            return answer;
        });
    })

    var pragmaticQuestioner = questioner(pragmaticAnswerer);

    // Standard RSA
    var literalListener = function(utterance) {
        return interpretAnswer(utterance);
    }

    var speaker = function(world) {
        return Infer({ method: 'enumerate' }, function() {
            var utterance = sample(answersDist);
            var L = literalListener(utterance);
            factor(L.score(world) * rationality);
            return utterance;
        })
    }

    var pragmaticListener = function(utterance) {
        return Infer({ method: 'enumerate' }, function() {
            var world = sample(worldPrior);
            var S = speaker(world);
            factor(S.score(utterance));
            return world;
        })
    }

    return { 
        Q1: explicitQuestioner, 
        A1: explicitAnswerer, 
        Q2: pragmaticQuestioner, 
        A2: pragmaticAnswerer,
        L0: literalListener,
        S1: speaker,
        L1: pragmaticListener
    };
}