var questionStartSymbol = "$WH";
var answerStartSymbol = "$S";

var KL = function(p, q){
    return expectation(p, function(value) {
        var scoreP = p.score(value);
        var scoreQ = q.score(value);
        return scoreP === -Infinity ? 0 : scoreP - scoreQ;
    });
};

var similarity = function(trueWorldPredicate, otherWorldPredicate, domain) {
    // trueWorldPredicate and otherWorldPredicate are each distributions
    // over subsets of the domain. Compute KL between them using factorization
    // for sequence of independent bernoulli trials.
    return Math.exp(-sum(map(function(e) {
        var p_e = trueWorldPredicate(e);
        var q_e = otherWorldPredicate(e);
        var positiveTerm = p_e === 0 ? 0 : p_e * Math.log(p_e / q_e);
        var negativeTerm = p_e === 1 ? 0 : (1 - p_e) * Math.log((1 - p_e) / (1 - q_e));
        return positiveTerm + negativeTerm;
    }, domain)));
}

var createVariationalModel = function(questions, answers, costFn, worldPrior, qudCandidates, 
                                      rationality, grammarFn, parametrizedNetworks, observationFn, 
                                      opts, experimentName, runId) {
    var runPath = makeRunPath(experimentName, runId);
    var modelFn = function() {
        var specifiedNetworks = mapObject(function(k, v) {
            var params = apply(v.paramConstructor, [k]);
            return v.runner(params);
        }, parametrizedNetworks)
        var grammar = grammarFn.call(null, specifiedNetworks);
        var parser = createParser(grammar, createParserWeights(grammar));
        var model = createModel(questions, answers, costFn, worldPrior, qudCandidates, rationality, parser);
        if (observationFn) {
            observationFn(model);
        }
        return _.assign({ networks: specifiedNetworks }, model);
    }

    if (fs.existsSync(runPath.paramsPath)) {
        // Restore previously learned params
        var params = webpplFs.read(runPath.paramsPath);
        setParams(deserializeParams(params));
    }
    else {
        // learn new params
        var optsWithFilenames = _.assign({ 
            model: modelFn,
            checkpointParamsFilename: runPath.paramsPath,
            logProgressFilename: runPath.logPath
        }, opts);
        Optimize(optsWithFilenames);
    }
                                     
    return sample(SampleGuide(modelFn));
}

var createModel = function(questions, answers, costFn, worldPrior, qudCandidates, rationality, parser) {
    var interpretAnswer = mem(function(answer) {
        var answerMeaning = parser(answer, answerStartSymbol);
        return Infer({method: 'enumerate'}, function() {
            var world = sample(worldPrior);
            factor(Math.log(answerMeaning(world)));
            return world;
        });
    })

    var answerQualityForQuestion = mem(function(answer, question, trueWorld) {
        // Using soft similarity semantics
        var questionPredicate = parser(question, questionStartSymbol);
        var consistentWorlds = interpretAnswer(answer);
        return Math.log(expectation(consistentWorlds, function(w) {
            assert.ok(w.domain.length === trueWorld.domain.length)
            var truePredicate = questionPredicate(trueWorld);
            var otherPredicate = questionPredicate(w);
            return similarity(truePredicate, otherPredicate, trueWorld.domain);
        }))
    })

    var answerQualityForQud = function(answer, qud, trueWorld) {
        // Using hard partition semantics
        var consistentWorlds = interpretAnswer(answer);
        return marginalize(consistentWorlds, qud).score(qud(trueWorld));
    }

    var sampleUtterance = function(utterances) {
        var probabilities = map(function(u) {
            return Math.exp(-rationality * costFn(u));
        }, utterances);
        return categorical(probabilities, utterances);
    }

    var informationGain = function(question, qudFn, trueWorld, answerer) {
        var prior = marginalize(worldPrior, qudFn);
        var answerDist = answerer(question, trueWorld);
        var posterior = Infer({method: 'enumerate'}, function() {
            var answer = sample(answerDist);
            var world = sample(interpretAnswer(answer));
            return qudFn(world);
        });

        return KL(posterior, prior);
    }

    var explicitAnswerer = mem(function(question, trueWorld) {
        return Infer({method: 'enumerate'}, function() {
            var answer = sampleUtterance(answers);
            var answerMeaning = parser(answer, answerStartSymbol);
            factor(Math.log(answerMeaning(trueWorld)) * rationality);
            factor(answerQualityForQuestion(answer, question, trueWorld)
                * rationality);
            return answer;
        })
    })

    var questioner = function(answerer) {
        return mem(function(qudIndex) {
            return Infer({method: 'enumerate'}, function() {
                var question = sampleUtterance(questions);
                var expectedInformationGain = expectation(worldPrior, function(world) {
                    return informationGain(question, qudCandidates[qudIndex], world, answerer);
                });
                factor(expectedInformationGain * rationality);
                return question;
            });
        })
    }

    var explicitQuestioner = questioner(explicitAnswerer);

    var pragmaticAnswerer = mem(function(question, trueWorld) {
        return Infer({method: 'enumerate'}, function() {
            var qudIndex = uniformDraw(_.keys(qudCandidates));
            var questionDist = explicitQuestioner(qudIndex);
            var answer = sampleUtterance(answers);
            factor((questionDist.score(question)
                    + answerQualityForQud(answer, qudCandidates[qudIndex], trueWorld))
                    * rationality);
            return answer;
        });
    })

    var pragmaticQuestioner = questioner(pragmaticAnswerer);

    // Standard RSA
    var literalListener = function(utterance) {
        return interpretAnswer(utterance);
    }

    var speaker = function(world) {
        return Infer({ method: 'enumerate' }, function() {
            var utterance = sampleUtterance(answers);
            var L = literalListener(utterance);
            factor(L.score(world) * rationality);
            return utterance;
        })
    }

    var pragmaticListener = function(utterance) {
        return Infer({ method: 'enumerate' }, function() {
            var world = sample(worldPrior);
            var S = speaker(world);
            factor(S.score(utterance));
            return world;
        })
    }

    return { 
        Q1: explicitQuestioner, 
        A1: explicitAnswerer, 
        Q2: pragmaticQuestioner, 
        A2: pragmaticAnswerer,
        L0: literalListener,
        S1: speaker,
        L1: pragmaticListener
    };
}