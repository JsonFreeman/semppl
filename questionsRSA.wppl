var questionStartSymbol = "$WH";
var answerStartSymbol = "$S";
// Change the name to parse to test model in isolation
var dummyParse = function(utterance) {
    if (utterance === ">0")
        return function(w) { return w.x > 0 ? 1 : 0; };
    if (utterance === "=0")
        return function(w) { return w.x === 0 ? 1 : 0; };
    if (utterance === "=1")
        return function(w) { return w.x === 1 ? 1 : 0; };
    if (utterance === "=2")
        return function(w) { return w.x === 2 ? 1 : 0; };
    if (utterance === "!=1")
        return function(w) { return w.x !== 1 ? 1 : 0; };
    if (utterance === ">0?")
        return function (w) { 
            return function(t) { return (w.x > 0) === t ? 1 : 0; };
        }
    if (utterance === "=0?")
        return function (w) { 
            return function(t) { return (w.x === 0) === t ? 1 : 0; };
        }
    if (utterance === "=1?")
        return function (w) { 
            return function(t) { return (w.x === 1) === t ? 1 : 0; };
        }
    if (utterance === "=2?")
        return function (w) { 
            return function(t) { return (w.x === 2) === t ? 1 : 0; };
        }
};

var KL = function(p, q){
    return expectation(p, function(value) {
        var scoreP = p.score(value);
        var scoreQ = q.score(value);
        return scoreP === -Infinity ? 0 : scoreP - scoreQ;
    });
};

var interpretAnswer = function(worldPrior, answer, parser) {
    var answerMeaning = parser(answer, 0, answerStartSymbol);
    return Infer({method: 'enumerate'}, function() {
        var world = sample(worldPrior);
        factor(Math.log(answerMeaning(world)));
        return world;
    });
}

var similarity = function(trueWorldPredicate, otherWorldPredicate, domain) {
    // trueWorldPredicate and otherWorldPredicate are each distributions
    // over subsets of the domain. Compute KL between them using factorization
    // for sequence of independent bernoulli trials.
    return Math.exp(-sum(map(function(e) {
        var p_e = trueWorldPredicate(e);
        var q_e = otherWorldPredicate(e);
        var positiveTerm = p_e === 0 ? 0 : p_e * Math.log(p_e / q_e);
        var negativeTerm = p_e === 1 ? 0 : (1 - p_e) * Math.log((1 - p_e) / (1 - q_e));
        return positiveTerm + negativeTerm;
    }, domain)));
}

var answerQualityForQuestion = function(worldPrior, answer, questionPredicate, trueWorld, parser) {
    // Using soft similarity semantics
    var consistentWorlds = interpretAnswer(worldPrior, answer, parser);
    return Math.log(expectation(consistentWorlds, function(w) {
        assert.ok(w.domain.length === trueWorld.domain.length)
        var truePredicate = questionPredicate(trueWorld);
        var otherPredicate = questionPredicate(w);
        return similarity(truePredicate, otherPredicate, trueWorld.domain);
    }))
}

var answerQualityForQud = function(worldPrior, answer, qud, trueWorld, parser) {
    // Using hard partition semantics
    var consistentWorlds = interpretAnswer(worldPrior, answer, parser);
    return marginalize(consistentWorlds, qud).score(qud(trueWorld));
}

var informationGain = function(questionPrior, worldPrior, answerPrior, question,
                               qudCandidates, qudFn, trueWorld, answerer, rationality, parser) {
    var prior = marginalize(worldPrior, qudFn);
    var answerDist = answerer(questionPrior, answerPrior, worldPrior, qudCandidates, question, trueWorld, rationality);
    var posterior = Infer({method: 'enumerate'}, function() {
        var answer = sample(answerDist);
        var world = sample(interpretAnswer(worldPrior, answer, parser));
        return qudFn(world);
    });

    return KL(posterior, prior);
}

var explicitAnswerer = function(questionPrior, answerPrior, worldPrior, qudCandidates, 
                                question, trueWorld, rationality, parser) {
    var questionMeaning = parser(question, 0, questionStartSymbol);
    return Infer({method: 'enumerate'}, function() {
        var answer = sample(answerPrior);
        var answerMeaning = parser(answer, 0, answerStartSymbol);
        factor(Math.log(answerMeaning(trueWorld)) * rationality);
        factor(answerQualityForQuestion(worldPrior, answer, questionMeaning, trueWorld, parser)
               * rationality);
        return answer;
    })
}

var questioner = function(answerer) {
    return function(questionPrior, answerPrior, worldPrior, qudFn, qudCandidates, rationality, parser) {
        return Infer({method: 'enumerate'}, function() {
            var question = sample(questionPrior);
            var expectedInformationGain = expectation(worldPrior, function(world) {
                return informationGain(questionPrior, worldPrior, answerPrior, question,
                    qudCandidates, qudFn, world, answerer, rationality, parser);
            });
            factor(expectedInformationGain * rationality);
            return question;
        });
    }
}

var pragmaticAnswerer = function(questionPrior, answerPrior, worldPrior, qudCandidates,
                                 question, trueWorld, rationality, parser) {
    var explicitQuestioner = questioner(explicitAnswerer);
    return Infer({method: 'enumerate'}, function() {
        var qud = uniformDraw(qudCandidates);
        var questionDist = explicitQuestioner(questionPrior, answerPrior, worldPrior, qud, qudCandidates, rationality, parser);
        var answer = sample(answerPrior);
        factor((questionDist.score(question)
                + answerQualityForQud(worldPrior, answer, qud, trueWorld, parser))
                * rationality);
        return answer;
    });
}

var pragmaticQuestioner = questioner(pragmaticAnswerer);

// Testing

var testAnswerer = function(answerer) {
    var questions = ["=0?", "=1?", "=2?"];
    var answers = ["=0", "=1", "=2"]
    var worlds = map(function(w) { extend(w, { domain: [true, false] }) }, [{ x: 0 }, { x: 1 }, { x: 2 }]);
    var trueWorld = worlds[2];
    var question = questions[1];
    var qudCandidates = [function (w) { return w.x > 0 }, function (w) { return w.x === 1 }, function (w) { return w.x === 2 }]
    display(answerer(
        Categorical({vs: questions, ps: repeat(questions.length, constF(1))}),
        Categorical({vs: answers, ps: repeat(answers.length, constF(1))}),
        Categorical({vs: worlds, ps: repeat(worlds.length, constF(1))}),
        qudCandidates, question, trueWorld, 1, /*parser*/ null)) // Use dummyParse
}

// testAnswerer(explicitAnswerer);
// testAnswerer(pragmaticAnswerer);

var testExplicitQuestioner = function() {
    var questions = [">0?", "=1?"];
    var answers = [">0", "=0", "=1", "!=1"]
    var worlds = [{ x: 0 }, { x: 1 }, { x: 2 }];
    var explicitQuestioner = questioner(explicitAnswerer);
    var qudCandidates = [function (w) { return w.x > 0 }, function (w) { return w.x === 1 }, idF]
    display(explicitQuestioner(
        Categorical({vs: questions, ps: repeat(questions.length, constF(1))}), 
        Categorical({vs: answers, ps: repeat(answers.length, constF(1))}),
        Categorical({vs: worlds, ps: repeat(worlds.length, constF(1))}),
        qudCandidates[3], qudCandidates, 1, /*parser*/ null)) // Use dummyParse
}

// testExplicitQuestioner();

var testSimilarityFunction = function() {
    var length = 5;
    var domain = _.range(0, length);
    var dist1 = repeat(length, function() { uniform(0, 1) });
    var dist2 = repeat(length, function() { uniform(0, 1) });
    var index = function(dist) { 
        return function (element) { dist[element] }
    }
    var sim = -Math.log(similarity(index(dist1), index(dist2), domain));

    var makeJointDist = function(dist) {
        return Infer({method: 'enumerate'}, function() {
            return map(bernoulli, dist);
        })
    }
    var kl = KL(makeJointDist(dist1), makeJointDist(dist2));

    assert.strictEqual(sim.toFixed(10), kl.toFixed(10));
}

// testSimilarityFunction();

var testIntegratedAnswerer = function(answerer, parser) {
    var questions = ["Who is a doctor", "Who is a teacher", "Who is a fisherman"];
    var answers = ["John is a doctor", "John is a teacher", "John is a fisherman"]
    var worlds = [  { domain: ["john", "mary"], facts: { doctor: ["john"], teacher: [], fisherman: []}},
                    { domain: ["john", "mary"], facts: { doctor: [], teacher: ["john"], fisherman: []}},
                    { domain: ["john", "mary"], facts: { doctor: [], teacher: [], fisherman: ["john"]}},
                    { domain: ["john", "mary"], facts: { doctor: ["john", "mary"], teacher: [], fisherman: []}},
                    { domain: ["john", "mary"], facts: { doctor: [], teacher: ["john", "mary"], fisherman: []}},
                    { domain: ["john", "mary"], facts: { doctor: [], teacher: [], fisherman: ["john", "mary"]}},]
    var trueWorld = worlds[2];
    var question = questions[1];
    var qudCandidates = [function (w) { return w.x > 0 }, function (w) { return w.x === 1 }, function (w) { return w.x === 2 }]
    display(answerer(
        Categorical({vs: questions, ps: repeat(questions.length, constF(1))}),
        Categorical({vs: answers, ps: repeat(answers.length, constF(1))}),
        Categorical({vs: worlds, ps: repeat(worlds.length, constF(1))}),
        qudCandidates, question, trueWorld, 1, parser))
}

testIntegratedAnswerer(explicitAnswerer, createParser(semppl.fixedGrammar, {}))
testIntegratedAnswerer(pragmaticAnswerer, createParser(semppl.fixedGrammar, {}))