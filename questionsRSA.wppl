var questionStartSymbol = "$WH";
var answerStartSymbol = "$S";

var KL = function(p, q){
    return expectation(p, function(value) {
        var scoreP = p.score(value);
        var scoreQ = q.score(value);
        return scoreP === -Infinity ? 0 : scoreP - scoreQ;
    });
};

var interpretAnswer = function(worldPrior, answer, parser) {
    var answerMeaning = parser(answer, 0, answerStartSymbol);
    return Infer({method: 'enumerate'}, function() {
        var world = sample(worldPrior);
        factor(Math.log(answerMeaning(world)));
        return world;
    });
}

var similarity = function(trueWorldPredicate, otherWorldPredicate, domain) {
    // trueWorldPredicate and otherWorldPredicate are each distributions
    // over subsets of the domain. Compute KL between them using factorization
    // for sequence of independent bernoulli trials.
    return Math.exp(-sum(map(function(e) {
        var p_e = trueWorldPredicate(e);
        var q_e = otherWorldPredicate(e);
        var positiveTerm = p_e === 0 ? 0 : p_e * Math.log(p_e / q_e);
        var negativeTerm = p_e === 1 ? 0 : (1 - p_e) * Math.log((1 - p_e) / (1 - q_e));
        return positiveTerm + negativeTerm;
    }, domain)));
}

var answerQualityForQuestion = function(worldPrior, answer, questionPredicate, trueWorld, parser) {
    // Using soft similarity semantics
    var consistentWorlds = interpretAnswer(worldPrior, answer, parser);
    return Math.log(expectation(consistentWorlds, function(w) {
        assert.ok(w.domain.length === trueWorld.domain.length)
        var truePredicate = questionPredicate(trueWorld);
        var otherPredicate = questionPredicate(w);
        return similarity(truePredicate, otherPredicate, trueWorld.domain);
    }))
}

var answerQualityForQud = function(worldPrior, answer, qud, trueWorld, parser) {
    // Using hard partition semantics
    var consistentWorlds = interpretAnswer(worldPrior, answer, parser);
    return marginalize(consistentWorlds, qud).score(qud(trueWorld));
}

var costFn = constF(1);

var sampleUtterance = function(utterances) {
    return categorical(map(costFn, utterances), utterances);
}

var createVariationalModel = function(questions, answers, worldPrior, qudCandidates, 
                                      rationality, grammar, predicates, observationFn, opts, testName) {
    var paramsPath = 'qaParams/' + testName + '-params.json';
    var modelFn = function() {
        var parser = createParser(grammar, makeModelParams(grammar, predicates, /*hiddenSize*/ 10));
        var model = createModel(questions, answers, worldPrior, qudCandidates, rationality, parser);
        if (observationFn) {
            observationFn(model);
        }
        return model;
    }

    if (webpplFs.node.existsSync(paramsPath)) {
        // Restore previously learned params
        var params = fs.read(paramsPath);
        setParams(deserializeParams(params));
    }
    else {
        // learn new params
        var optsWithFilenames = _.assign({ 
            model: modelFn,
            checkpointParamsFilename: paramsPath,
            logProgressFilename: 'qaTrainingLogs/' + testName + '-log.csv' 
        }, opts);
        Optimize(optsWithFilenames);
    }
                                     
    return sample(SampleGuide(modelFn));
}

var createModel = function(questions, answers, worldPrior, qudCandidates, rationality, parser) {
    var informationGain = function(question, qudFn, trueWorld, answerer) {
        var prior = marginalize(worldPrior, qudFn);
        var answerDist = answerer(question, trueWorld);
        var posterior = Infer({method: 'enumerate'}, function() {
            var answer = sample(answerDist);
            var world = sample(interpretAnswer(worldPrior, answer, parser));
            return qudFn(world);
        });

        return KL(posterior, prior);
    }

    var explicitAnswerer = function(question, trueWorld) {
        var questionMeaning = parser(question, 0, questionStartSymbol);
        return Infer({method: 'enumerate'}, function() {
            var answer = sampleUtterance(answers);
            var answerMeaning = parser(answer, 0, answerStartSymbol);
            factor(Math.log(answerMeaning(trueWorld)) * rationality);
            factor(answerQualityForQuestion(worldPrior, answer, questionMeaning, trueWorld, parser)
                * rationality);
            return answer;
        })
    }

    var questioner = function(answerer) {
        return function(qudIndex) {
            return Infer({method: 'enumerate'}, function() {
                var question = sampleUtterance(questions);
                var expectedInformationGain = expectation(worldPrior, function(world) {
                    return informationGain(question, qudCandidates[qudIndex], world, answerer);
                });
                factor(expectedInformationGain * rationality);
                return question;
            });
        }
    }

    var pragmaticAnswerer = function(question, trueWorld) {
        var explicitQuestioner = questioner(explicitAnswerer);
        return Infer({method: 'enumerate'}, function() {
            var qud = uniformDraw(qudCandidates);
            var questionDist = explicitQuestioner(qud);
            var answer = sampleUtterance(answers);
            factor((questionDist.score(question)
                    + answerQualityForQud(worldPrior, answer, qud, trueWorld, parser))
                    * rationality);
            return answer;
        });
    }

    var explicitQuestioner = questioner(explicitAnswerer);
    var pragmaticQuestioner = questioner(pragmaticAnswerer);

    return { Q1: explicitQuestioner, A1: explicitAnswerer, Q2: pragmaticQuestioner, A2: pragmaticAnswerer };
}