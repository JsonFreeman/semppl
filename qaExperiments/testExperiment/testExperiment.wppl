var testName = "testOptimize";
var questions = ["Who is a doctor", "Who is a teacher", "Who is a fisherman"]
var answers = ["John is a doctor", "John is a teacher", "John is a fisherman",
                    "John and Mary is a doctor", "John and Mary is a teacher", "John and Mary is a fisherman"]
var worlds = [  { domain: ["john", "mary"], facts: { doctor: ["john"], teacher: [], fisherman: []}},
                { domain: ["john", "mary"], facts: { doctor: [], teacher: ["john"], fisherman: []}},
                { domain: ["john", "mary"], facts: { doctor: [], teacher: [], fisherman: ["john"]}},
                { domain: ["john", "mary"], facts: { doctor: ["john", "mary"], teacher: [], fisherman: []}},
                { domain: ["john", "mary"], facts: { doctor: [], teacher: ["john", "mary"], fisherman: []}},
                { domain: ["john", "mary"], facts: { doctor: [], teacher: [], fisherman: ["john", "mary"]}},]
var qudCandidates = [function(w) { w.facts.teacher }];
var qudCandidatesRange = _.range(qudCandidates.length);

var generateDataModel = createModel(questions, answers, Categorical({ vs: worlds, ps: ones([worlds.length]).toFlatArray() }),
                                    qudCandidates, 1, createParser(semppl.fixedGrammar, []))

var data = readOrGenerateTrainingData(testName, [questions, answers, worlds, qudCandidatesRange], 
    function(q, a, w, qudIndex) {
        return apply(generateDataModel.A1, [q, w]);
    }, 5);

var model = createVariationalModel(questions, answers, Categorical({ vs: worlds, ps: ones([worlds.length]).toFlatArray() }),
    qudCandidates, 1, semppl.neuralPredicateGrammar, ['doctor', 'teacher', 'fisherman'], function(model) {
        mapData({ data: data, batchSize: 10 }, function(d) {
            observe(apply(model.A1, [d[0], d[2]]), d[1]);
        })
    }, 
    { optimizer: 'adam', 
      steps: 20, 
      estimator: 'ELBO', 
      checkGradients: false, 
      checkpointParams: true,
      logProgress: true
    }, testName);

computeAndWriteResults(testName, [
    { model: model.A1, query: [questions[0], worlds[0], /*qudIndex*/ 0] },
    { model: model.Q1, query: [/*qudIndex*/ 0] }
]);