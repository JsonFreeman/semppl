// Paths
var makeRunPath = function(experimentName, runId) {
    var dir = "qaExperiments/" + experimentName + "/run" + runId;
    var basePath = dir + "/" + experimentName + "-" + runId;
    return { 
        dir: dir,
        dataPath: basePath + "-data.json",
        paramsPath: basePath + "-params.json",
        logPath: basePath + "-log.csv"
    };
}

// Generating data and results
var generateTrainingData = function(listOfLists, fn, numSamples) {
    var recursiveMap = function(listOfLists, fn, numSamples, args /* internal*/) {
        if (listOfLists.length === 0) {
            var resultDist = apply(fn, args);
            return repeat(numSamples, function() {
                return snoc(args, sample(resultDist));
            })
        }

        var restEntries = rest(listOfLists);
        return _.flatten(map(function(e) { 
            recursiveMap(restEntries, fn, numSamples, snoc(args, e))
        }, first(listOfLists)), /*shallow*/ true)
    };
    
    return recursiveMap(listOfLists, fn, numSamples, []);
}

var readOrGenerateTrainingData = function(experimentName, runId, listOfLists, fn, numSamples) {
    var runPath = makeRunPath(experimentName, runId);
    if (webpplFs.node.existsSync(runPath.dataPath)) {
        return json.read(runPath.dataPath);
    }

    var data = generateTrainingData(listOfLists, fn, numSamples);
    json.write(runPath.dataPath, data);
    return data;
}

var computeAndWriteResults = function(filename, queryAndModelPairs) {
    var results = map(function(queryAndModel) {
        return {
            query: queryAndModel.query,
            result: apply(queryAndModel.model, queryAndModel.query)
        }
    }, queryAndModelPairs);

    json.write('qaExperimentsOutput/' + filename + '-results.json', results);
    return results;
}